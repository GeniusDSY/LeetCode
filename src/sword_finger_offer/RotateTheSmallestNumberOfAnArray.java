package sword_finger_offer;

/**
 * @author :DengSiYuan
 * @date :2020/2/21 20:41
 * @desc :面试题11.旋转数组的最小数字
 * 【题目】
 *      把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  
 * 【示例】
 *      输入：[3,4,5,1,2]
 *      输出：1
 *
 *      输入：[2,2,2,0,1]
 *      输出：0
 */
public class RotateTheSmallestNumberOfAnArray {

    /**
     * 【解法】     二分法（减治思想）
     *      【算法流程】
     *          1、循环二分： 设置i,j指针分别指向 numbers 数组左右两端，m=(i+2)/2为每次二分的中点
     *          （向下取整，因此恒有i<=m<j），可分为以下三种情况：
     *              1、当 numbers[m] > numbers[j]时：m一定在左排序数组中，即旋转点x一定在[m+1,j] 闭区间内，因此执行i=m+1；
     *              2、当 numbers[m] < numbers[j] 时：m一定在右排序数组中，即旋转点x一定在[i,m] 闭区间内，因此执行j=m；
     *              3、当 numbers[m] == numbers[j] 时： 无法判断m在哪个排序数组中，因此无法判断旋转点x在[i,m] 还是[m+1,j]
     *              区间中，结论是执行j=j−1 缩小判断范围 （分析见以下内容） 。
     *          2、返回值：i=j时跳出二分循环，并返回 numbers[i] 即可。
     *          3、numbers[m] == numbers[j] 情况分析：
     *              1、无法判定m在左（右）排序数组举例： 设以下两个旋转点值为0的示例数组，则当i=0,j=4 时m=2 。
     *              通过以下两示例可发现，不同数组结果不同。
     *                  例[1,0,1,1,1] ：旋转点m在右排序数组中。
     *                  例[1,1,1,0,1] ：旋转点m在左排序数组中。
     *              2、j=j−1操作的正确性证明：只需证明执行此操作后，旋转点x仍在[i,j]区间内即可。
     *                  若m在右排序数组中： numbers[m] == numbers[j] ，因此数组[m,j]（恒有m<j）区间内所有元素值相等，
     *                  执行j=j−1 只会抛弃一个重复值，因此旋转点x仍在[i,j]区间内。
     *                  若m在左排序数组中： 由于左排序数组任一元素>=右排序数组任一元素，因此可推出旋转点元素值
     *                  numbers[x]<=numbers[j]==numbers[m]，则有：
     *                      若 numbers[x] < numbers[j] ： 则j左方仍有值更小的元素，执行j=j−1后旋转点x仍在[i,j]区间内。
     *                      若 numbers[x] == numbers[j] ： 分为以下两种情况。
     *                          当j在旋转点右侧： 易得执行j=j−1后旋转点x仍在[i,j]区间内。
     *                          当j为旋转点： 这里为特殊情况，例如[1,1,1,2,3,1]最终返回的是 numbers[0] 而不是旋转点 numbers[5]。
     *                          即当i=0,j=5,m=2时执行j=j−1后虽然丢失了旋转点索引x但最终返回值仍正确这是因为：
     *                          之后的二分循环一直在执行j=m，而区间[i,m]内的元素值都等于旋转点值 numbers[x]，
     *                          因此仍可保证正确的返回值 。
     * 【复杂度分析】
     *      时间复杂度O(logN) ：在特例情况下（例如[1,1,1,1]），会退化到O(N)。
     *      空间复杂度O(1)：i,j,m指针使用常数大小的额外空间。
     */
    public int minArray1(int[] numbers) {
        int i = 0, j = numbers.length - 1;
        while (i < j) {
            int m = (i + j) >>> 1;
            if (numbers[m] > numbers[j]){
                i = m + 1;
            }
            else if (numbers[m] < numbers[j]){
                j = m;
            }
            else{
                j--;
            }
        }
        return numbers[i];
    }
}
